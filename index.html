<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - panorama with depth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <link rel="stylesheet" href="/css/styles.css">

	</head>
	<body>
		<div id="container"></div>
        <div class="buttons">
            <button id="removeFurnitureButton">Remove Furniture</button>
            <button id="redesignButton">Redesign</button>
        </div>
        
        
        <div class="dropdown">
            <div class="select">
                <span class="selected">Escenas</span>
                <div class="caret"></div>
            </div>
            <ul class="menu" id="imageMenu">
            </ul>
        </div>



		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
            import { VRButton } from '/jsm/webxr/VRButton.js';

            let camera, scene, renderer, sphere, clock;
            let scenesData;

            init();

            function init() {
                const container = document.getElementById('container');
                clock = new THREE.Clock();

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x101010);

                const light = new THREE.AmbientLight(0xffffff, 3);
                scene.add(light);

                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 2000);
                scene.add(camera);

                const panoSphereGeo = new THREE.SphereGeometry(6, 256, 256);
                const panoSphereMat = new THREE.MeshStandardMaterial({
                    side: THREE.BackSide,
                    displacementScale: -4.0
                });

                sphere = new THREE.Mesh(panoSphereGeo, panoSphereMat);
                scene.add(sphere);

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setAnimationLoop(animate);
                renderer.xr.enabled = true;
                renderer.xr.setReferenceSpaceType('local');
                container.appendChild(renderer.domElement);

                document.body.appendChild(VRButton.createButton(renderer));
                window.addEventListener('resize', onWindowResize);

                loadJSONData();
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                if (renderer.xr.isPresenting === false) {
                    const time = clock.getElapsedTime();
                    sphere.rotation.y += 0.001;
                    sphere.position.x = Math.sin(time) * 0.2;
                    sphere.position.z = Math.cos(time) * 0.2;
                }
                renderer.render(scene, camera);
            }

            function loadJSONData() {
                fetch('./data.json')
                    .then(response => response.json())
                    .then(data => {
                        scenesData = data;
                        console.log(scenesData)
                        populateImageList(scenesData.scenes);
                    })
                    .catch(error => console.error('Error loading JSON data:', error));
            }

            function populateImageList(scenes) {
                const imageMenu = document.getElementById('imageMenu');
                scenes.forEach((scene, index) => {
                    const li = document.createElement('li');
                    li.textContent = scene.name;
                    li.onclick = () => changeScene(index);
                    imageMenu.appendChild(li);
                });
            }

            function changeScene(index) {
                const sceneData = scenesData.scenes[index];
                const loader = new THREE.TextureLoader();
                loader.load(sceneData.image, function (texture) {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.NearestFilter;
                    texture.generateMipmaps = false;
                    sphere.material.map = texture;
                    sphere.material.needsUpdate = true;
                })
            }


		</script>
        <script src="/js/index.js"></script>
	</body>
</html>
